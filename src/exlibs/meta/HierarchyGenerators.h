// ======================================================================================
// File         : HierarchyGenerators.h
// Author       : Wu Jie 
// Last Change  : 08/18/2009 | 00:20:57 AM | Tuesday,August
// Description  : 
// ======================================================================================

////////////////////////////////////////////////////////////////////////////////
// The Loki Library
// Copyright (c) 2001 by Andrei Alexandrescu
// This code accompanies the book:
// Alexandrescu, Andrei. "Modern C++ Design: Generic Programming and Design 
//     Patterns Applied". Copyright (c) 2001. Addison-Wesley.
// Permission to use, copy, modify, distribute and sell this software for any 
//     purpose is hereby granted without fee, provided that the above copyright 
//     notice appear in all copies and that both that copyright notice and this 
//     permission notice appear in supporting documentation.
// The author or Addison-Wesley Longman make no representations about the 
//     suitability of this software for any purpose. It is provided "as is" 
//     without express or implied warranty.
////////////////////////////////////////////////////////////////////////////////

// #################################################################################
#ifndef HIERARCHYGENERATORS_H_1250526060
#define HIERARCHYGENERATORS_H_1250526060
// #################################################################################

///////////////////////////////////////////////////////////////////////////////
// includes
///////////////////////////////////////////////////////////////////////////////

#include "meta/typeop.h"
#include "meta/typelist.h"

// ######################### 
namespace ex { 
// ######################### 

// ######################### 
namespace _private { 
// ######################### 

    ///////////////////////////////////////////////////////////////////////////////
    // class ScatterHierarchyTag
    // 
    // Purpose: 
    //  The following type helps to overcome subtle flaw in the original 
    //  implementation of GenScatterHierarchy. 
    //  The flaw is revealed when the input type list of GenScatterHierarchy 
    //  contains more then one element of the same type (e.g. LOKI_TYPELIST_2(int, int)). 
    //  In this case GenScatterHierarchy will contain multiple bases of the same 
    //  type and some of them will not be reachable (per 10.3).
    //  For example before the fix the first element of Tuple<LOKI_TYPELIST_2(int, int)>
    //  is not reachable in any way!
    // 
    ///////////////////////////////////////////////////////////////////////////////

    template <class,class> struct ScatterHierarchyTag;

// ######################### 
} // end namespace _private 
// ######################### 

///////////////////////////////////////////////////////////////////////////////
// class GenScatterHierarchy
// 
// Purpose: 
//  Generates a scattered hierarchy starting from a typelist and a template
//  Invocation (TYPE_LIST_T is a typelist, UNIT_T is a template of one arg):
//  GenScatterHierarchy<TypeList, Unit>
//  The generated class inherits all classes generated by instantiating the 
//  template 'Unit' with the types contained in TypeList 
// 
// Example:
//  ex::GenScatterHierarchy< ex::Seq<int,uint32,uint64>::typelist_t, TTestClass > hchy;
//  TTestClass<int>& test_int = hchy;
//  test_int.m_Value = 1;
//  TTestClass<uint32>& test_uint32 = hchy;
//  test_uint32.m_Value = 2;
//  TTestClass<uint64>& test_uint64 = hchy;
//  test_uint64.m_Value = 3;
// 
///////////////////////////////////////////////////////////////////////////////

// ======================================================== 
// GenScatterHierarchy < TYPE_LIST_T, UNIT_T >
// ======================================================== 

template <class TYPE_LIST_T, template <class> class UNIT_T>
class GenScatterHierarchy;

// ======================================================== 
// GenScatterHierarchy < T1, T2, UNIT_T >
// ======================================================== 

template <class T1, class T2, template <class> class UNIT_T>
class GenScatterHierarchy<TypeList<T1, T2>, UNIT_T>
    : public GenScatterHierarchy<_private::ScatterHierarchyTag<T1, T2>, UNIT_T>
    , public GenScatterHierarchy<T2, UNIT_T>
{
    ///////////////////////////////////////////////////////////////////////////////
    // typedefs
    ///////////////////////////////////////////////////////////////////////////////

public:

    typedef TypeList<T1, T2> type_list_t;

    // Insure that left_base_t is unique and therefore reachable
    typedef GenScatterHierarchy<_private::ScatterHierarchyTag<T1, T2>, UNIT_T> left_base_t;
    typedef GenScatterHierarchy<T2, UNIT_T> right_base_t;

    //
    template <typename T> struct Rebind { typedef UNIT_T<T> result_t; }; // end struct Rebind
}; // end class GenScatterHierarchy

// ======================================================== 
// In the middle *unique* class that resolve possible ambiguity
// ======================================================== 

template <class T1, class T2, template <class> class UNIT_T>
class GenScatterHierarchy<_private::ScatterHierarchyTag<T1, T2>, UNIT_T> 
    : public GenScatterHierarchy<T1, UNIT_T>
{
}; // end class GenScatterHierarchy 

// ======================================================== 
// GenScatterHierarchy < ATOMIC_T, UNIT_T >
// ======================================================== 

template <class ATOMIC_T, template <class> class UNIT_T>
class GenScatterHierarchy : public UNIT_T<ATOMIC_T>
{
    typedef UNIT_T<ATOMIC_T> left_base_t;
    template <typename T> struct Rebind
    {
        typedef UNIT_T<T> result_t;
    };
}; // end class GenScatterHierarchy

// ======================================================== 
// GenScatterHierarchy < UNIT_T >
// ======================================================== 

template <template <class> class UNIT_T>
class GenScatterHierarchy<NullType, UNIT_T>
{
    template <typename T> struct Rebind
    {
        typedef UNIT_T<T> result_t;
    };
}; // end class GenScatterHierarchy

///////////////////////////////////////////////////////////////////////////////
// class GenLinearHierarchy
// 
// Purpose: 
//  Generates a linear hierarchy starting from a typelist and a template
//  Invocation (TYPE_LIST_T is a typelist, UNIT_T is a template of two args):
//  GenScatterHierarchy<TypeList, Unit>
// 
///////////////////////////////////////////////////////////////////////////////

// ======================================================== 
// GenLinearHierarchy <TYPE_LIST_T,UNIT_T>
// ======================================================== 

template 
< 
    class TYPE_LIST_T, 
    template <class AtomicType, class Base> class UNIT_T, 
    class ROOT_T = EmptyType 
> 
class GenLinearHierarchy;

// ======================================================== 
// GenLinearHierarchy <T1,T2,UNIT_T,ROOT_T>
// ======================================================== 

template
<
    class T1,
    class T2,
    template <class, class> class UNIT_T,
    class ROOT_T
>
class GenLinearHierarchy<TypeList<T1, T2>, UNIT_T, ROOT_T> 
    : public UNIT_T< T1, GenLinearHierarchy<T2, UNIT_T, ROOT_T> >
{
}; // end class GenLinearHierarchy 

// ======================================================== 
// GenLinearHierarchy <T,UNIT_T,ROOT_T>
// ======================================================== 

template
<
    class T,
    template <class, class> class UNIT_T,
    class ROOT_T
>
class GenLinearHierarchy<TypeList<T, NullType>, UNIT_T, ROOT_T>
    : public UNIT_T<T, ROOT_T>
{
}; // end class GenLinearHierarchy 

// ======================================================== 
// GenLinearHierarchy <UNIT_T,ROOT_T>
// ======================================================== 

template
<
    template <class, class> class UNIT_T,
    class ROOT_T
>
class GenLinearHierarchy<NullType, UNIT_T, ROOT_T>
    : public ROOT_T // is this better: UNIT_T<NullType, ROOT_T> ?
{
}; // end class GenLinearHierarchy 

#if 0
////////////////////////////////////////////////////////////////////////////////
// function template Field
// Accesses a field in an object of a type generated with GenScatterHierarchy
// Invocation (obj is an object of a type H generated with GenScatterHierarchy,
//     T is a type in the typelist used to generate H):
// Field<T>(obj)
// returns a reference to UNIT_T<T>, where UNIT_T is the template used to generate H 
////////////////////////////////////////////////////////////////////////////////

// ------------------------------------------------------------------ 
// Desc: 
// ------------------------------------------------------------------ 

template <class T, class H>
typename H::template Rebind<T>::result_t& Field ( H& _obj ) { return _obj; }

// ------------------------------------------------------------------ 
// Desc: 
// ------------------------------------------------------------------ 

template <class T, class H>
const typename H::template Rebind<T>::result_t& Field ( const H& _obj ) { return _obj; }

////////////////////////////////////////////////////////////////////////////////
// function template TupleUnit
// The building block of tuples 
////////////////////////////////////////////////////////////////////////////////

template <class T>
struct TupleUnit
{
    T value_;
    operator T&() { return value_; }
    operator const T&() const { return value_; }
};

////////////////////////////////////////////////////////////////////////////////
// class template Tuple
// Implements a tuple class that holds a number of values and provides field 
//     access to them via the Field function (below) 
////////////////////////////////////////////////////////////////////////////////

template <class TYPE_LIST_T>
struct Tuple : public GenScatterHierarchy<TYPE_LIST_T, TupleUnit>
{
};

////////////////////////////////////////////////////////////////////////////////
// helper class template FieldHelper
// See Field below
////////////////////////////////////////////////////////////////////////////////

template <class H, unsigned int i> struct FieldHelper;

template <class H>
struct FieldHelper<H, 0>
{
    typedef typename H::typelist_t::Head ElementType;
    typedef typename H::template Rebind<ElementType>::result_t UnitType;

    enum
    {
        isTuple = Conversion<UnitType, TupleUnit<ElementType> >::sameType,
        isConst = TypeTraits<H>::isConst
    };

    typedef const typename H::left_base_t ConstLeftBase;

    typedef typename Select<isConst, ConstLeftBase, 
            typename H::left_base_t>::result_t left_base_t;

    typedef typename typeop::Select<isTuple, ElementType, 
            UnitType>::result_t UnqualifiedResultType;

    typedef typename typeop::Select<isConst, const UnqualifiedResultType,
            UnqualifiedResultType>::result_t ResultType;

    static ResultType& Do(H& obj)
    {
        left_base_t& leftBase = obj;
        return leftBase;
    }
};

template <class H, unsigned int i>
struct FieldHelper
{
    typedef typename typelist::TypeAt<typename H::typelist_t, i>::result_t ElementType;
    typedef typename H::template Rebind<ElementType>::result_t UnitType;

    enum
    {
        isTuple = Conversion<UnitType, TupleUnit<ElementType> >::sameType,
        isConst = TypeTraits<H>::isConst
    };

    typedef const typename H::right_base_t ConstRightBase;

    typedef typename typeop::Select<isConst, ConstRightBase, 
            typename H::right_base_t>::result_t right_base_t;

    typedef typename typeop::Select<isTuple, ElementType, 
            UnitType>::result_t UnqualifiedResultType;

    typedef typename typeop::Select<isConst, const UnqualifiedResultType,
            UnqualifiedResultType>::result_t ResultType;

    static ResultType& Do(H& obj)
    {
        right_base_t& rightBase = obj;
        return FieldHelper<right_base_t, i - 1>::Do(rightBase);
    }
};

////////////////////////////////////////////////////////////////////////////////
// function template Field
// Accesses a field in an object of a type generated with GenScatterHierarchy
// Invocation (obj is an object of a type H generated with GenScatterHierarchy,
//     i is the index of a type in the typelist used to generate H):
// Field<i>(obj)
// returns a reference to UNIT_T<T>, where UNIT_T is the template used to generate H
//     and T is the i-th type in the typelist 
////////////////////////////////////////////////////////////////////////////////

template <int i, class H>
    typename FieldHelper<H, i>::ResultType&
Field(H& obj)
{
    return FieldHelper<H, i>::Do(obj);
}

//    template <int i, class H>
//    const typename FieldHelper<H, i>::ResultType&
//    Field(const H& obj)
//    {
//        return FieldHelper<H, i>::Do(obj);
//    }
#endif

// ######################### 
} // end namespace ex 
// ######################### 

// #################################################################################
#endif // END HIERARCHYGENERATORS_H_1250526060
// #################################################################################

